// The file generator generates a file containing a const instance of Config
// User has to provide a instance of TmpConfig that can be written to file
// User can specify the location of the output file

use crate::config::{TmpConfig, self, NodeID, MacAdress};
use std::io::Write;
use std::fs;

pub fn generate(config: &TmpConfig, path: &String) {
    let mut file = fs::File::create(path).unwrap();
    writeln!(file, "// This file is auto generated by a build.rs file and cope_config").unwrap();
    writeln!(file, "use cope_config::config::*;\n").unwrap();
    write_nodes(&mut file, config);
    // write_relay(&mut file, config);
    // write_black_list(&mut file, config);
    // writeln!(file, "static config: TmpConfig = Config::new(nodes, relay, black_list)").unwrap();
}

fn write_nodes(file: &mut fs::File, config: &TmpConfig) {
    let mut nodes = String::new();
    nodes.push_str("[\n");
    for (n, m) in config.nodes() {
        let node = node_id_to_string(n);
        let mac = mac_adr_to_string(m);
        nodes.push_str(&format!("    ({},{}),\n",node, mac));
    }
    nodes.push_str("]");
    writeln!(file, "let nodes: Vec<(NodeID, MacAdress)> = vec!{};", nodes).unwrap();
}

fn write_relay(file: &mut fs::File, config: &TmpConfig) {
    let relay = node_id_to_string(&config.relay());
    writeln!(file, "    relay: {}", relay).unwrap();
}

fn write_black_list(file: &mut fs::File, config: &TmpConfig) {
    let black_list = String::new();
    writeln!(file, "    black_list: {}", black_list).unwrap();
}

fn node_id_to_string(node_id: &NodeID) -> String {
    format!("NodeID::new('{}')", node_id)
}

fn mac_adr_to_string(mac_adr: &MacAdress) -> String {
    let mut str = String::new();
    str.push_str("MacAdress::new([");
    for byte in mac_adr.into_iter() {
        str.push_str(&format!("{},", byte));
    }
    str.push_str("])");
    str
}
