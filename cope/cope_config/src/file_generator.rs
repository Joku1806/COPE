// The file generator generates a file containing a const instance of Config
// User has to provide a instance of TmpConfig that can be written to file
// User can specify the location of the output file

use crate::config::{TmpConfig, self, NodeID, MacAdress};
use std::io::Write;
use std::fs;

pub fn generate(config: &TmpConfig, path: &String) {
    let mut file = fs::File::create(path).unwrap();
    let node_count = config.nodes().len();
    // TODO: check for correcness of input
    // TODO: remove all the unwraps
    writeln!(file, "// This file is auto generated by a build.rs file and cope_config").unwrap();
    writeln!(file, "use cope_config::config::*;\n").unwrap();
    writeln!(file, "pub const CONFIG: Config<{}> = Config{{", node_count).unwrap();
    write_nodes(&mut file, config);
    write_relay(&mut file, config);
    write_black_list(&mut file, config, node_count);
    writeln!(file, "}};").unwrap();
}

fn write_nodes(file: &mut fs::File, config: &TmpConfig) {
    let mut nodes = String::new();
    nodes.push_str("[\n");
    for (n, m) in config.nodes() {
        let node = node_id_to_string(n);
        let mac = mac_adr_to_string(m);
        nodes.push_str(&format!("        ({}, {}),\n",node, mac));
    }
    nodes.push_str("    ]");
    writeln!(file, "    nodes: {},", nodes).unwrap();
}

fn write_relay(file: &mut fs::File, config: &TmpConfig) {
    let relay = node_id_to_string(&config.relay());
    writeln!(file, "    relay: {},", relay).unwrap();
}

fn write_black_list(file: &mut fs::File, config: &TmpConfig, node_count: usize) {
    let mut black_list = String::new();
    black_list.push_str("[\n");
    for (node, _) in config.nodes() {
        let node_id = node_id_to_string(node);
        let list = config.black_list()
            .iter()
            .find(|(n, _)| *n == *node)
            .map(|(_, l)| l);
        let bl_atr = node_list_to_string(list, node_count);
        black_list.push_str(&format!("        ({}, {}),\n", node_id, bl_atr));
    }
    black_list.push_str("    ]");
    writeln!(file, "    black_list: {}", black_list).unwrap();
}

fn node_id_to_string(node_id: &NodeID) -> String {
    format!("NodeID::cnst('{}')", node_id)
}

fn mac_adr_to_string(mac_adr: &MacAdress) -> String {
    let mut str = String::new();
    str.push_str("MacAdress::cnst([");
    for byte in mac_adr.into_iter() {
        str.push_str(&format!("{},", byte));
    }
    str.push_str("])");
    str
}

fn node_list_to_string(list_opt: Option<&Vec<NodeID>>, node_count: usize) -> String {
    let mut str = String::new();
    str.push_str("[\n            ");
    if let Some(list) = list_opt {
        for n in list {
            let node = node_id_to_string(n);
            str.push_str(&format!("Some({}),\n            ", node));
        }
    }
    let list_len = list_opt.map_or(0, |l| l.len());
    assert_eq!(true, node_count >= list_len);
    for _ in 0..(node_count - list_len) {
        str.push_str("None, ");
    }
    str.push_str("\n        ]");
    str
}
